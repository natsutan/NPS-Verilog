(use srfi-19)
(use srfi-13)
(use file.util)

(define-class <npsv-fixed> ()
  ((W :init-keyword :W) ; Whole bit width
   (I :init-keyword :I) ; Inter bit width
   (Q :init-keyword :Q :init-value 'SC_TRN)  ; quantize mode
   (O :init-keyword :O :init-value #f)  ; overflow mode, reserved
   (N :init-keyword :N :init-value #f)  ; reserved
   ))  

(define-class <npsv-port> ()
  ((name :init-keyword :name)
   (dir :init-keyword :dir)
   (lsb :init-keyword :lsb :init-value 0)
   (msb :init-keyword :msb :init-value 0)
   (special :init-keyword :special :init-value #f)
   (comment :init-keyword :comment :init-value "")
   (type :init-keyword :type :init-value 'signal)))


(define-class <npsv-fixed-port> (<npsv-port>)
  ((fixed-info :init-keyword :fixed-info)))

(define-class <npsv-module> ()
  ((name :init-keyword :name)
   (type :init-keyword :type)
   (ports :init-value '())
   (comment :init-keyword :comment :init-value "")
   (registers :init-value '())
   (processes :init-value '())
   (wires :init-value '() )))

(define-class <npsv-reg> ()
  ((name :init-keyword :name)
   (lsb :init-keyword :lsb :init-value 0)
   (msb :init-keyword :msb :init-value 0)))

(define-class <npsv-process> ()
  ((label :init-keyword :label :init-value "")
   (reset_process :init-keyword :reset)
   (process :init-keyword :process)))

(define-class <npsv-wire> ()
   ((name :init-keyword :name)
    (assign :init-keyword :assign)))

(define-class <npsv-2dmem> (<npsv-reg>)
  ((adr-w :init-keyword :adr-w)))
   

(define-method initialize ((self <npsv-module>) initargs)
  (next-method)
  (let ((clk (make <npsv-port> :name "clk" :dir 'input :spetial #t))
	(reset_x (make <npsv-port> :name "reset_x" :dir 'input :spetial #t)))
    (add-port self clk)
    (add-port self reset_x)))

(define-method add-port ((inst <npsv-module>) (port <npsv-port>))
  (set! (ref inst 'ports) (cons port (ref inst 'ports))))
    
(define-method add-process ((inst <npsv-module>) (process <npsv-process>))
  (set! (ref inst 'processes) (cons processes (ref inst 'processes))))
  
(define-method add-reg ((inst <npsv-module>) (reg <npsv-reg>))
  (set! (ref inst 'registers) (cons reg (ref inst 'registers))))
  
(define-method add-wire ((inst <npsv-module>) (process <npsv-wire>))
  (set! (ref inst 'wires) (cons processes (ref inst 'wires))))

(define-method print ((inst <npsv-module>))
  (print (string-concatenate  (list "<npsv-module> " (ref inst 'name) " (" (symbol->string (ref inst 'type)) ")" )))
  ;(next-method)
  )

(define-method print ((p <npsv-port>))
  (print (make-port-string p)))

(define-method print ((p <npsv-fixed-port>))
  (let ((fp (ref p 'fixed-info)))
    (let ((W (number->string (ref fp 'W)))
          (I (number->string (ref fp 'I))))
      (print (string-append
              (make-port-string p)
              "   (W:" W ",I:" I ")")))))

(define print-instance
  (lambda (inst)
    (print inst)
    (print (string-concatenate (list "\"" (ref inst 'comment) "\"")))
    (dolist (p (ref inst 'ports)) (print p))))

(define make-port-string
  (lambda (p)
    (let* ((dir (symbol->string (ref p 'dir)))
           (lsb (ref p 'lsb))
           (msb (ref p 'msb))
           (name (ref p 'name))
           (slise (if (and (zero? lsb) (zero? msb))
                      ""
                      (string-append "[" (number->string msb) ":" (number->string lsb) "]"))))
      (string-append dir " " slise " " name))))


;;;--------------------------------------------------------------------------------
;;; RTL
;;;--------------------------------------------------------------------------------
(define write-header
  (lambda (fp name)
    (format fp "//-------------------------------------------------~%")
    (format fp "// ~A~%" name)
    (format fp "// This file was auto-generated by npsv ~A~%" (date->string (current-date) "~5"))
    (format fp "//-------------------------------------------------~%")))

(define write-module-declaration
  (lambda (fp inst)
    (format fp "module ~A~%" (ref inst 'name))
    (format fp "(~%")
    (dolist (p (reverse (ref inst 'ports)))
            (write-port fp p))
    (format fp ");~%")
    ))

(define write-port
  (lambda (fp p)
    (let* ((dir (symbol->string (ref p 'dir)))
           (lsb (ref p 'lsb))
           (msb (ref p 'msb))
           (name (ref p 'name))
           (type (ref p 'type))
           (comment (ref p 'comment)))
      (let ((slise_s (if (and (zero? lsb) (zero? msb))
                         ""
                         (string-append "[" (number->string msb) ":" (number->string lsb) "]")))
            (comment_s (if (string=? (ref p 'comment) "")
                           ""
                           (string-append "// " (ref p 'comment))))
            (type_s (if (eqv? type 'reg)
                        "reg "
                        "")))
        (format fp "\t~A ~A ~A ~A;~%" dir type_s slise_s name)))))

(define write-module-declaration-end
  (lambda (fp)
    (format fp "endmodule~%")))


(define write-verilog-file
  (lambda (inst dir)
    (let* ((name (ref inst 'name))
           (fp (open-verilog-file dir name)))
      (write-header fp name)
      (write-module-declaration fp inst)

      (write-module-declaration-end fp)
      (close-verilog-file fp))))

;;;--------------------------------------------------------------------------------
;;; file
;;;--------------------------------------------------------------------------------
(define open-verilog-file
  (lambda (dir name)
    (let ((fname (string-append dir "/" name ".v")))                 
      (make-directory* dir)
      (format #t "open ~A~%" fname)
      (open-output-file fname)
      )))

(define close-verilog-file
  (lambda (fp)
    (close-output-port fp)))

(define load-setting-file
  (lambda (fname)
    (format #t "load ~A" fname)
    (load fname)))

;;misc
(define usage-exit
  (lambda (program-name)
    (format #t "Usage: gosh ~A setting-file~%" program-name)
    (exit 1)))

